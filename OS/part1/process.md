# 프로세스와 스레드

### 프로세스
컴퓨터에서 실행 중인 하나의 프로그램을 의미하며, 프로그램은 특정 작업을 수행하기 위한 명령어의 집합이다.
프로세스는 OS로부터 독립된 메모리 영역을 할당 받고, 다른 영역에는 접근할 수 없다.

### 프로세스의 메모리 영역 구조
<img width="400" alt="스크린샷 2024-07-29 오전 11 07 11" src="https://github.com/user-attachments/assets/5e621973-9048-49e8-a570-17ca114f541b"><br/>
1. 스택 : **LIFO** 으로 동작, 지역 변수, 함수의 매개변수, 반환되는 주소 값들이 저장되는 영역<br/>
2. 힙 : **FIFO** 으로 동작, 사용자에 의해 동적 메모리 할당이 일어나는 영역으로, malloc() 으로 할당되는 영역<br/>
3. 데이터 : 전역 변수, 정적 변수, 배열, 구조체 등이 저장되는 영역, **BSS(Block Stated Symbol)** 으로 초기화 되지 않은 영역과 초기화 된 영역으로 세분화됨<br/>
4. 코드 : 실행할 코드가 기계어로 컴파일 되어 동작하는 영역으로, 텍스트 영역이라 한다.<br/>

- 스택 영역이 힙 영역을 침범하는 것이 **스택 오버플로**, 힙 영역이 스택 영역을 침범하는 것을 **힙 오버플로** 라고 한다.

### 스레드
스레드는 프로세스에서 실제로 실행되는 흐름의 단위를 의미. <br/>
스레드는 프로세스 안에 존재하기에, 프로세스의 메모리 공간을 이용하고, 지역 변수를 저장하는 스택 영역을 할당 받음. <br/>
전역 변수를 저장하는 힙 영역은 다른 스레드와 공유함

### PCB (Process Control Block)
OS는 프로세스를 제어하기 위한 프로세스 정보를 저장하는데, 이를 PCB 라고 함. <br/>
프로세스의 현재 상태, 프로세스를 나타내는 고유의 Process ID, 다음 프로그램의 명령어 주소인 PC, 메모리 제한 등을 관리함

### 프로세스의 생성
새로운 프로세스는 기존 프로세스에서 fork() 함수를 호출해 생성함. <br/>
fork() 함수에는 함수를 호출한 프로세스를 복사하는 기능이 있음. 이때, 기존 프로세스를 부모, 복사된 프로세스를 자식 프로세스라고 함<br/>

함수 값 반환 예시
```
#include <stdio.h>
#include <unistd.h>

int main() {
  printf("Start!\n");
  int forkRet = fork();

  if (forkRet == 0){
    printf("child process : %d\n",getpid());
  } else {
    printf("forkRet : %d, parent process : %d\n", forkRet, getpid());
  }

  return 0;
}
```
<br/>
실행 결과 <br/>
> Start! <br/>
> forkRet : 136, parent process : 135 <br/>
> child process : 136
<br/>

<br/>
처음 부모에서 Start! 실행 후, fork() 실행시, 자식의 프로세스를 생성하게 됨. <br/>
따라서, 반환값은 자식의 PID인 136이 되고, else 문에 들어가서 출력문을 출력하게 됨 <br/>
자식 프로세스는 부모가 호출한 시점에 생성됨으로 반환값이 0이 되어 if문 안에 들어가게 되고, <br/>
자신의 PID을 호출하며 함수가 끝이 난다.
<br/>

### 프로세스의 상태도
생성 - 준비 - 대기 - 실행 - 종료의 5가지 상태가 있다. <br/>
<img width="600" src="https://user-images.githubusercontent.com/59963677/139288242-13e5faa3-9363-4387-8e4f-fa4f85af718a.png">

1. 생성 : 프로세스가 PCB을 가지고 있지만 OS로부터 승인 받기 전
2. 준비 : OS로부터 승인받은 후에 큐에서 CPU 할당을 기다림
3. 실행 : 프로세스가 CPU을 할당받아서 시행
4. 대기 : 프로세스가 입출력이나 이벤트 발생을 기다려야해서 CPU 사용을 멈추고 기다림
5. 종료 : 프로세스 실행 종료

### 멀티 프로세스와 멀티 스레드
* 동시성 : 하나의 코어에서 여러 작업을 번갈아가면서 처리하는 것. CPU는 한번에 하나만 처리할 수 있어서 여러 작업을 조금씩 번갈아가면서 처리하기 위해 처리 중인 작업을 교체하면서 처리함.
* 병렬성 : CPU가 여러 개 있어서, 각 CPU에서 각 작업을 동시에 처리하는 방식 (물리적 관점에서 동시에 여러 작업 실행!)

1. 멀티 프로세서
- 응용 프로그램 하나를 여러 프로세서로 구성하는 것으로 한 프로세서가 죽어도 다른 프로세스에 영향을 주지 않음 (따라서 여러 개로 구성하는 것이 안전!)
- 시간과 메모리를 많이 사용한다는 단점이 있음 <br/>
  : CPU는 하나의 작업만 사용할 수 있기에 콘텍스트 스위칭 과정에서 일어나는 오버헤드나, 프로세스 간의 공유해야할 자원이 있을 시 **IPC** 을 통해 해야된다. 따라서 직접 참조보다 비효율적임.
  
2. 멀티 스레드
- 스레드를 여러 개 생성해 스레드들이 각자 다른 작업을 처리하는 것을 의미
- 멀티 스레드는 스레드 간 힙,데이터,코드 영역을 공유함. 따라서, 오버헤드가 적고 IPC을 안해도 되어서 멀티 프로세스의 단점 보완이 가능
- 스택 영역을 다른 스레드 간 같이 사용함으로 공유 자원에 대한 동기화가 필수
- 스레드 내에 문제가 생길 시, 다른 스레드에도 영향이 생길 수 있음

### Context Switching (컨텍스트 스위칭)
* 인터럽트 (Interrupt) : 입출력 관련 이벤트가 발생하거나 예외 발생시 대응할 수 있게 CPU에 처리를 요청하는 것
<br/><br/>
P1을 처리중에 P2 요청이 들어오게 되었을 때의 예시,<br/>
<img width="600" src="https://velog.velcdn.com/images/kimunche/post/6c1588cf-6085-4605-887b-97a16cc5b168/image.png"><br/>
P1에 작업 정보를 PCB에 저장 -> P2의 PCB에서 정보 가져와 CPU P2 처리 시작 -> P2 끝 -> P1 다시 시작 <br/>

이전 작업 정보를 저장하고, 다음 작업 정보를 로드하는 과정에서 CPU가 아무것도 못하는 상태와 같이, <br/>
어떤 처리를 하는데 간접적인 처리 시간 및 메모리가 소요되는 것을 "오버헤드 발생" 이라고 한다. <br/>

### 프로세스 동기화 
1. 경쟁 상태
- 공유 자원에 동시에 접근해 경쟁하는 상태
- 서로 동기화가 되지 않아 의도치 않은 자원 낭비가 발생할 수 있음 (ex> 너무 많은 우유 문제)

2. 임계 영역
- 공유 자원에 접근할 수 있고, 접근 순서에 따라 결과가 달라지는 영역임. (우유 문제에서 냉장고 안에 우유 확인하고 추가하는 부분)
- 여러 프로세스가 공유 자원에 같이 접근해도 데이터의 일관성이 유지되도록 **프로세스 동기화**가 필요
- 3가지 조건이 충족되어야 함
  1. 상호 배제 기법 : 어떤 프로세스가 임계 영역을 실행 중일 때 다른 프로세스가 임계 영역에 접근할 수 없음 (뮤텍스와 세마포어 기법)
  2. 진행 : 임계 영역을 실행중인 프로세스 없을 때 다른 프로세스가 임계 영역을 실행
  3. 한정된 대기 : 임계 영역에 접근 요청했을 때 무한한 시간 대기 하지 않음

<br/>
3. 뮤텍스
- 락(lock)을 가진 프로세스만이 공유 자원에 접근 가능하게 하는 기법
- **락킹 매커니즘** : 임계 영역에 먼저 접근한 프로세스가 락을 걸면, 다른 프로세스는 락이 해제되기 전까지 대기해야됨. 
- 임계 영역에 접근하지 못한 프로세스는 락을 얻기 위해 기다리는 동안 반복문을 돌면서 락이 풀린지를 확인한다. **(바쁜 대기 - 스핀락)**

<br/>
4. 세마포어
- 공유 자원에 접근할 수 있는 프로세스의 수를 정해 접근을 제어하는 방법
- 임계 영역에 접근할 수 있는 프로세스의 개수를 정수 변수로 정해두고, 이 중 하나를 가진 프로세스만이 임계 영역에 접근하게 하는 방식
- 공유 자원에 접근한 프로세스가 접근을 해제하면 다른 프로세스가 접근할 수 있도록 신호를 보낸다는 **시그널링 매커니즘** 임.
<br/>

### 교착 상태
- 상호배제 기법 때문에 2개 이상의 프로세스가 자원을 가지고 있으면서 서로의 자원을 요구하며 기다리는 상태
- 교착 상태가 일어나는 4가지의 필요충분 조건이 있다. (막으려면 이 4가지 중 하나의 조건을 제거하면 됨!)
  1. 상호 배제 : 하나의 공유 자원에는 하나의 프로세스만 들어갈 수 있음.
  2. 점유와 대기 : 프로세스가 최소 하나의 자원을 점유하고 있는 상태에서 추가로 다른 프로세스에서 사용중인 자원을 점유하기 위해 대기한다
  3. 비선점 : 다른 프로세스에 할당된 자원을 뺏을 수 없음
  4. 환형 대기 : 프로세스가 자신의 자원을 점유하면서 앞, 뒤에 있는 프로세스의 자원을 요구함.
<br/>

### 스레드 안전
- 멀티 스레드 환경에서 하나의 변수, 함수, 객체에 스레드 여러개가 동시에 접근해도 문제가 없음을 의미함.

### IPC (Inter Process Communication) : 프로세스 간의 자원을 공유하는 방식
1. 공유 메모리
- 프로세스 간의 공유 가능한 메모리를 구성하여 자원을 공유하는 방식, 동기화 문제가 발생할 수 있음
2. 소켓
- 네트워크 소켓을 이용한 프로세스 간 통신, 외부 시스템과도 이용할 수 있음. client-sever 구조로 자원 공유
3. 세마포어
- 접근하는 프로세스를 제어하여 공유 자원 관리
4. 파이프
- FIFO 형태의 메모리 파이프를 이용하여 프로세스 간 자원을 공유하는 방식.
- 파이프는 단방향 통신만 지원함으로 읽기/쓰기 중 하나만 할 수 있음.
- 양방향 통신 하려면 읽기/쓰기 파이프를 각각 생성해야함.
5. 메세지 큐
- FIFO 형태의 큐 자료구조 사용하여 프로세스 간 메세지를 주고 받음.

### 좀비 프로세스, 고아 프로세스
1. 좀비 프로세스
- 자식 프로세스가 종료되었는데 부모 프로세스가 자식 프로세스의 종료 상태를 회수하지 못해 남겨진 자식 프로세스를 의미
- SIGCHLD의 시그널로 부모 프로세스에서 wait() 호출하여 자원 회수 하는데 실패하여서 남겨지는 것
- 좀비 프로세스들이 쌓이면 자원이 낭비됨

2. 고아 프로세스
- 부모 프로세스가 자식 프로세스보다 먼저 종료되는 것을 의미
- 자식 프로세스의 PID을 init 프로세스인 PID 1으로 바꿔주는 방식을 통해 고아 프로세스가 작업 종료하면 Init이 회수하여 좀비가 되는 것을 방지
