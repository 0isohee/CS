1. C 언어의 메모리 구조를 설명하고 각 섹션의 역할을 서술하세요. <br/>
코드: 실행 가능한 코드가 저장됩니다. <br/>
데이터: 초기화된 데이터 세그먼트: 초기화된 전역 변수와 정적 변수가 저장됩니다.<br/>
   초기화되지 않은 데이터 세그먼트 (BSS): 초기화되지 않은 전역 변수와 정적 변수가 저장됩니다. <br/>
힙: 동적 메모리 할당 시 사용되는 공간입니다. <br/>
스택: 함수 호출 시 지역 변수와 리턴 주소 등이 저장됩니다.<br/>
<br/>

2. 포인터와 배열의 차이점을 설명하세요. <br/>
포인터는 변수의 주소를 저장하는 변수입니다. <br/>
배열은 동일한 타입의 요소들이 연속된 메모리 공간에 저장되는 자료구조입니다. <br/>
배열은 선언 시 크기가 고정되지만, 포인터는 동적 메모리 할당을 통해 크기를 조정할 수 있습니다.<br/>
<br/>

3. 포인터를 이용하여 문자열을 복사하는 코드를 작성하세요.<br/>
```
void myStrcpy(char *dest, const char *src) {
    while (*src) {
        *dest++ = *src++;
    }
    *dest = '\0';
}
```

4. 동적 메모리 할당과 해제에 대해 설명하고, malloc, calloc, realloc, free의 사용법을 예제와 함께 설명하세요.<br/>

malloc: 주어진 바이트 수만큼 메모리를 할당합니다. <br/>
```
int *p = (int *)malloc(10 * sizeof(int));
```
calloc: 할당된 메모리를 0으로 초기화합니다. <br/>
```
int *p = (int *)calloc(10, sizeof(int));
```
realloc: 이미 할당된 메모리의 크기를 변경합니다.<br/>
```
p = (int *)realloc(p, 20 * sizeof(int));
```
free: 할당된 메모리를 해제합니다.<br/>
```
free(p);
```

5. 스택 오버플로우가 발생할 수 있는 상황과 이를 방지하는 방법을 설명하세요.<br/>
스택 오버플로우는 함수 호출이 너무 깊거나, 스택 공간을 초과할 정도로 큰 지역 변수를 할당할 때 발생합니다.<br/>
이를 방지하려면:<br/>
재귀 호출을 줄입니다.<br/>
큰 배열은 동적 메모리 할당을 통해 힙에 저장합니다.<br/>
컴파일러 옵션을 사용해 스택 크기를 조정합니다.<br/>
<br/>

6. 함수 포인터를 정의하고 사용하는 방법을 설명하세요. 예제를 포함하세요.<br/>
```
// 함수 포인터 정의
int (*funcPtr)(int, int);

// 함수 정의
int add(int a, int b) {
    return a + b;
}

// 함수 포인터에 함수 주소 할당
funcPtr = add;

// 함수 포인터 사용
int result = funcPtr(3, 4); // 결과는 7
```

7. 구조체와 공용체의 차이점을 설명하고, 각 용도에 대해 설명하세요.<br/>
구조체: 여러 다른 타입의 변수를 묶어 하나의 타입으로 사용할 수 있습니다. 각 멤버는 개별적인 메모리 공간을 가집니다.<br/>
공용체: 여러 다른 타입의 변수가 동일한 메모리 공간을 공유합니다. 한 시점에 하나의 변수만 저장할 수 있습니다.<br/>
구조체 사용 예:<br/>
```
struct Person {
    char name[50];
    int age;
    float height;
};
```
공용체 사용 예:
```
union Data {
    int i;
    float f;
    char str[20];
};
```

8. 비트 연산자의 종류와 사용법을 예제와 함께 설명하세요.<br/>

AND (&): 두 비트가 모두 1일 때 1
```
int a = 5 & 3; // a는 1
```
OR (|): 두 비트 중 하나 이상이 1일 때 1
```
int b = 5 | 3; // b는 7
```
XOR (^): 두 비트가 서로 다를 때 1
```
int c = 5 ^ 3; // c는 6
```
NOT (~): 비트를 반전
```
int d = ~5; // d는 -6
```
Left Shift (<<): 비트를 왼쪽으로 이동
```
int e = 5 << 1; // e는 10
```
Right Shift (>>): 비트를 오른쪽으로 이동
```
int f = 5 >> 1; // f는 2
```

9. volatile 키워드의 역할을 설명하고, 언제 사용하는지 예를 들어 설명하세요.<br/>
volatile 키워드는 변수의 값을 컴파일러가 캐시하지 않도록 하여, 항상 메모리에서 직접 읽도록 합니다.<br/>
하드웨어 레지스터, ISR에서 변경되는 변수 등에 사용합니다.<br/>
```
volatile int flag;
```

10. 매크로와 함수의 차이점을 설명하고, 매크로를 사용할 때 주의해야 할 점을 설명하세요.<br/>
매크로는 전처리기에 의해 텍스트 치환됩니다.<br/>
함수는 런타임에 호출됩니다.<br/>
매크로는 인자에 괄호를 사용하여 예상치 못한 동작을 방지해야 합니다.<br/>
```
#define SQUARE(x) ((x) * (x))
```

11. 리틀 엔디안과 빅 엔디안의 차이를 설명하고, 이를 확인하는 코드를 작성하세요.<br/>
리틀 엔디안: 낮은 바이트가 낮은 주소에 저장<br/>
빅 엔디안: 높은 바이트가 낮은 주소에 저장<br/>
```
int check_endian() {
    unsigned int x = 1;
    char *c = (char*)&x;
    return (*c == 1) ? 1 : 0; // 리틀 엔디안이면 1 반환
}
```

12. 임베디드 시스템에서 인터럽트와 폴링의 차이점을 설명하고, 각각의 장단점을 설명하세요.<br/>
인터럽트: 하드웨어 이벤트 발생 시 CPU에 알림<br/>
장점: CPU 자원을 효율적으로 사용<br/>
단점: 복잡한 설계 필요<br/>
--------------------------------<br/>
폴링: CPU가 주기적으로 상태를 확인<br/>
장점: 구현이 간단<br/>
단점: CPU 자원 낭비<br/>

13. 임베디드 시스템에서 타이머를 설정하고 사용하는 방법을 설명하세요.<br/>
타이머 설정: 타이머 레지스터와 인터럽트를 사용<br/>
예제:<br/>
```
// 타이머 초기화
void timer_init() {
    // 타이머 레지스터 설정
    TCCR1B |= (1 << WGM12); // CTC 모드
    TCCR1B |= (1 << CS12);  // 프리스케일러 설정
    TIMSK1 |= (1 << OCIE1A); // 타이머 인터럽트 활성화
    OCR1A = 15624; // 비교 값 설정
}
```

14. 상수 포인터와 포인터 상수의 차이를 설명하세요.<br/>
상수 포인터 (pointer to const): 포인터가 가리키는 값이 변경되지 않음
```
const int *p;
```
포인터 상수 (const pointer): 포인터 자체가 변경되지 않음
```
int *const p;
```

15. 링크드 리스트를 정의하고, 단일 링크드 리스트의 삽입 및 삭제 함수를 작성하세요.<br/>
정의:<br/>
```
struct Node {
    int data;
    struct Node *next;
};
```
삽입:
```
void insert(struct Node** head, int data) {
    struct Node* newNode = (struct Node*)malloc(sizeof(struct Node));
    newNode->data = data;
    newNode->next = *head;
    *head = newNode;
}
```
삭제:
```
void delete(struct Node** head, int key) {
    struct Node* temp = *head, *prev = NULL;
    if (temp != NULL && temp->data == key) {
        *head = temp->next;
        free(temp);
        return;
    }
    while (temp != NULL && temp->data != key) {
        prev = temp;
        temp = temp->next;
    }
    if (temp == NULL) return;
    prev->next = temp->next;
    free(temp);
}
```

16. 데드락의 개념을 설명하고, 데드락을 방지하기 위한 방법들을 설명하세요.<br/>
데드락: 둘 이상의 프로세스가 서로가 가진 자원을 기다리며 무한히 대기하는 상태<br/>
방지 방법:<br/>
자원 할당 순서 부여<br/>
자원 사전 할당<br/>
타임아웃 설정<br/>

17. 세마포어와 뮤텍스의 차이점을 설명하고, 사용 예제를 작성하세요.<br/>
세마포어: 카운터로 임계 구역 접근을 제어, 여러 프로세스가 동시에 접근 가능<br/>
뮤텍스: 상호 배제를 위해 사용, 하나의 프로세스만 접근 가능<br/>
사용 예제 (뮤텍스):<br/>
```
pthread_mutex_t lock;

void *thread_func(void *arg) {
    pthread_mutex_lock(&lock);
    // 임계 구역
    pthread_mutex_unlock(&lock);
    return NULL;
}
```

18. C 언어에서 재귀 함수의 장단점을 설명하고, 재귀 함수를 사용한 피보나치 수열 생성 코드를 작성하세요.<br/>
장점: 간결하고 이해하기 쉬운 코드<br/>
단점: 함수 호출 오버헤드, 스택 오버플로우 가능성<br/>
```
int fibonacci(int n) {
    if (n <= 1) return n;
    return fibonacci(n-1) + fibonacci(n-2);
}
```

19. 정적 변수와 정적 함수의 차이점을 설명하고, 각각의 사용 예를 작성하세요.<br/>
정적 변수: 함수 내에서 선언되면 함수 호출 간에 값을 유지, 파일 내에서 선언되면 파일 내에서만 접근 가능<br/>
```
void func() {
    static int count = 0;
    count++;
}
```
정적 함수: 함수가 정의된 파일 내에서만 접근 가능
```
static void staticFunc() {
    // 파일 내에서만 접근 가능
}
```

20. 이중 포인터의 개념을 설명하고, 이를 사용하여 2차원 배열을 동적으로 할당하는 코드를 작성하세요.<br/>
이중 포인터: 포인터를 가리키는 포인터<br/>
```
int **allocate_2d_array(int rows, int cols) {
    int **arr = (int **)malloc(rows * sizeof(int *));
    for (int i = 0; i < rows; i++) {
        arr[i] = (int *)malloc(cols * sizeof(int));
    }
    return arr;
}
```

21. 임베디드 시스템에서 전원 관리 기법을 설명하고, C 언어에서 이를 구현하는 방법을 설명하세요.<br/>

전원 관리 기법: CPU 주파수 조정, 전력 소모가 적은 모드 사용<br/>
```
void enter_low_power_mode() {
    // 전력 소모가 적은 모드로 전환
    // MCU에 따라 다양한 방법이 존재
}
```

22. C 언어에서의 형 변환의 종류와 사용법을 설명하세요. (암시적 변환과 명시적 변환)<br/>
암시적 변환: 자동으로 타입 변환<br/>
```
int a = 10;
float b = a; // 암시적 변환
```
명시적 변환: 캐스트 연산자를 사용한 타입 변환
```
float c = 10.5;
int d = (int)c; // 명시적 변환
```

23. 동적 라이브러리와 정적 라이브러리의 차이점을 설명하고, 각각의 장단점을 설명하세요.<br/>
정적 라이브러리: 컴파일 시 바이너리에 포함<br/>
장점: 실행 파일이 독립적<br/>
단점: 파일 크기 증가<br/>
--------------------------------<br/>
동적 라이브러리: 실행 시 로드<br/>
장점: 파일 크기 감소, 업데이트 용이<br/>
단점: 런타임 의존성<br/>

24. 임베디드 시스템에서 UART 통신의 기본 원리를 설명하고, 이를 제어하는 코드를 작성하세요.<br/>
UART 통신: 직렬 통신 방식, 시작 비트, 데이터 비트, 패리티 비트, 정지 비트로 구성<br/>
```
void uart_init() {
    // UART 초기화 코드
    UBRR0 = 103; // Baud rate 설정
    UCSR0B = (1 << RXEN0) | (1 << TXEN0); // 송수신 활성화
    UCSR0C = (1 << UCSZ01) | (1 << UCSZ00); // 데이터 비트 설정
}
```

25. 파일 입출력 함수의 종류와 사용법을 예제와 함께 설명하세요.<br/>
파일 입출력 함수: fopen, fclose, fread, fwrite, fprintf, fscanf<br/>
```
FILE *file = fopen("example.txt", "w");
if (file != NULL) {
    fprintf(file, "Hello, World!\n");
    fclose(file);
}
```

26. C 언어에서의 메모리 누수의 개념을 설명하고, 이를 탐지하고 해결하는 방법을 설명하세요.<br/>
메모리 누수: 할당된 메모리가 해제되지 않고 남아있는 상태<br/>
탐지 및 해결: 코드 리뷰, 메모리 디버거 사용, 적절한 free 호출<br/>
```
int *p = (int *)malloc(10 * sizeof(int));
// 사용 후
free(p);
```

27. 경쟁 조건의 개념을 설명하고, 이를 방지하기 위한 기법을 설명하세요.<br/>
경쟁 조건: 여러 프로세스가 동시에 접근하여 예기치 않은 결과를 초래하는 상황<br/>
방지 기법: 뮤텍스, 세마포어, 모니터, 락 등을 사용<br/>
```
pthread_mutex_t lock;
pthread_mutex_lock(&lock);
// 임계 구역
pthread_mutex_unlock(&lock);
```

28. 캐시의 개념을 설명하고, 임베디드 시스템에서 캐시의 역할을 설명하세요.<br/>
캐시: CPU와 메모리 사이의 데이터 접근 속도를 향상시키기 위한 임시 저장소<br/>
역할: 자주 사용되는 데이터의 접근 시간을 단축하여 성능 향상<br/>
<br/>

29. 컴파일 과정에서 전처리기, 컴파일러, 링커의 역할을 설명하세요.<br/>
전처리기: 매크로 처리, 파일 포함, 조건부 컴파일<br/>
컴파일러: 소스 코드를 어셈블리 코드로 변환<br/>
링커: 여러 오브젝트 파일을 하나의 실행 파일로 결합<br/>
<br/>

30. 인터럽트 서비스 루틴(ISR)의 작성 방법을 설명하고, 주의해야 할 점을 설명하세요.<br/>
작성 방법: 인터럽트 발생 시 실행되는 함수
```
ISR(TIMER1_COMPA_vect) {
    // ISR 코드
}
```
주의 사항: ISR은 짧고 빠르게, 블로킹 호출 지양, 공유 자원 접근 시 적절한 동기화
